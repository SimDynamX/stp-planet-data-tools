# Various reused stuff for Platform python scripting

#All these modules here are part of Python already
from __future__ import absolute_import
import subprocess
import sys
import importlib
import os
from os import path

#######################################
### Macros/Saved Strings ##############

fullGreetingString = """[1m[38;2;255;255;255m[48;2;10;60;144m

      _____                       __________  ___    ____________
     / ___/____  ____ _________  / ____/ __ \\/   |  / ____/_  __/
     \\__ \\/ __ \\/ __ `/ ___/ _ \\/ /   / /_/ / /| | / /_    / /
    ___/ / /_/ / /_/ / /__/  __/ /___/ _, _/ ___ |/ __/   / /
   /____/ .___/\\__,_/\\___/\\___/\\____/_/ |_/_/  |_/_/     /_/
       /_/

[38;2;0;0;0m[48;2;230;230;230m     Space [4mC[24mollaborative [4mR[24meal-time [4mA[24mnalysis and [4mF[24mlight [4mT[24moolkit      [48;2;10;60;144m
[48;2;230;230;230m              TEES ASTRO Center - Texas A&M University              [48;2;10;60;144m[0m
[48;2;6;32;76m[1m[38;2;255;255;255m   SpaceCRAFT Platform Version:[0m[1m 0.7.6 (Release, Win64)
[48;2;6;32;76m[1m[38;2;255;255;255m                  Release Date:[0m[1m July 7, 2020"""

fullGreetingStringNoColor = """

      _____                       __________  ___    ____________
     / ___/____  ____ _________  / ____/ __ \\/   |  / ____/_  __/
     \\__ \\/ __ \\/ __ `/ ___/ _ \\/ /   / /_/ / /| | / /_    / /
    ___/ / /_/ / /_/ / /__/  __/ /___/ _, _/ ___ |/ __/   / /
   /____/ .___/\\__,_/\\___/\\___/\\____/_/ |_/_/  |_/_/     /_/
       /_/

     Space Collaborative Real-time Analysis and Flight Toolkit      
              TEES ASTRO Center - Texas A&M University              
   SpaceCRAFT Platform Version: 0.7.6 (Release, Win64)
                  Release Date: July 7, 2020"""


greetingString = """[1m[38;2;255;255;255m[48;2;10;60;144m

      _____                       __________  ___    ____________
     / ___/____  ____ _________  / ____/ __ \\/   |  / ____/_  __/
     \\__ \\/ __ \\/ __ `/ ___/ _ \\/ /   / /_/ / /| | / /_    / /
    ___/ / /_/ / /_/ / /__/  __/ /___/ _, _/ ___ |/ __/   / /
   /____/ .___/\\__,_/\\___/\\___/\\____/_/ |_/_/  |_/_/     /_/
       /_/

[38;2;0;0;0m[48;2;230;230;230m     Space [4mC[24mollaborative [4mR[24meal-time [4mA[24mnalysis and [4mF[24mlight [4mT[24moolkit      [48;2;10;60;144m
[48;2;230;230;230m              TEES ASTRO Center - Texas A&M University              [48;2;10;60;144m[0m"""

greetingStringNoColor = """

      _____                       __________  ___    ____________
     / ___/____  ____ _________  / ____/ __ \\/   |  / ____/_  __/
     \\__ \\/ __ \\/ __ `/ ___/ _ \\/ /   / /_/ / /| | / /_    / /
    ___/ / /_/ / /_/ / /__/  __/ /___/ _, _/ ___ |/ __/   / /
   /____/ .___/\\__,_/\\___/\\___/\\____/_/ |_/_/  |_/_/     /_/
       /_/

     Space Collaborative Real-time Analysis and Flight Toolkit      
              TEES ASTRO Center - Texas A&M University"""

#######################################
### Bootstrapping #####################

def scprint(*args, **kwargs):
    print( "[SC] "+" ".join(map(str,args))+"", **kwargs)

# Returns if the relative path given as an assumption of where the script is running
# matches with where the .RELPATHS_ANCHOR_FILE is.
def executingAtProperRelPath(assumed_rel_path_to_anchor_dir: str):
    return path.exists(assumed_rel_path_to_anchor_dir + "/.RELPATHS_ANCHOR_FILE")

def currently_in_venv():
    return (hasattr(sys, 'real_prefix') or
            (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix))

def makeVenvIfNotAlready(env_dir: str):
    if (os.name == 'nt'):
        binpath = os.path.join("Scripts","python.exe")
        osSpecificDir = "for_windows"
    else:
        binpath = os.path.join("bin","python") #TODO is this right?
        osSpecificDir = "for_posix"

    #NOTE: need os-specific dir so we don't have conflicts between venvs made by different OSs
    env_dir_os_specific = os.path.join(env_dir,osSpecificDir)

    scprint("Making venv at",env_dir_os_specific,"if it doesn't already exist...")

    pythonExePath = os.path.join(env_dir, osSpecificDir, binpath)
    pyvenvCfgPath = os.path.join(env_dir, osSpecificDir, "pyvenv.cfg")

    scprint("Checking existance of", pythonExePath)
    scprint("Also checking existance of", pyvenvCfgPath)

    if( (not path.exists(pythonExePath)) or (not path.exists(pyvenvCfgPath)) ):
        try:
            scprint("Didn't find venv at",env_dir_os_specific,"-- making one now.")
            subprocess.check_call([sys.executable, "-m", "venv", env_dir_os_specific])

            # make a file in here to mark that we autogenerated this venv
            with open(os.path.join(env_dir,".SC_AUTOGENERATED_VENV"), 'w') as fp: 
                pass
        except:
            scprint("Exception while making venv at",env_dir_os_specific)
            raise Exception()
            # TODO should I wait for input here, so people definitely don't have the terminal close on them?
    else:
        scprint("Found venv at",env_dir)
    
def runScriptInVenv(env_dir: str, script_file: str):
    #https://stackoverflow.com/questions/6943208/activate-a-virtualenv-with-a-python-script
    # Path to a Python interpreter that runs any Python script
    # under the virtualenv /path/to/virtualenv/
    if (os.name == 'nt'):
        binpath = os.path.join("Scripts","python.exe")
        osSpecificDir = "for_windows"
    else:
        binpath = os.path.join("bin","python") #TODO is this right?
        osSpecificDir = "for_posix"

    #NOTE: need os-specific dir so we don't have conflicts between venvs made by different OSs
    env_dir_os_specific = os.path.join(env_dir,osSpecificDir)

    # Only make env dir OS-specific if we were the ones that made it
    if(path.exists( os.path.join(env_dir,".SC_AUTOGENERATED_VENV"))):
        pythonExePath = os.path.join(env_dir_os_specific, binpath)
    else:
        pythonExePath = os.path.join(env_dir, binpath)

    subprocess.check_call([pythonExePath, script_file])

# Use pip3 or pip to modules from a requirements.txt
def installRequirements(reqs_filepath: str):
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "-r", reqs_filepath])
    except:
        subprocess.check_call([sys.executable, "-m", "pip3", "install", "-r", reqs_filepath])
